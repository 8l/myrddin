use "die.use"
use "sys.use"
use "types.use"
use "utf.use"

pkg std =
	const bfmt	: (buf : byte[,], fmt : byte[,], args:... -> size)
	const put	: (fmt : byte[,], args:... -> size)
;;

const put = {fmt, args
	var buf : byte[2048]
	var n
	
	n = bfmt(buf[0,2048], fmt, args)
	write(1, buf[0,n])
	-> n
}

const bfmt = {buf, fmt, args
	var c
	var n
	var ap
	var s_val;
	var b_val;
	/*
	var w_val;
	*/
	var i_val;
	var l_val;

	n = 0
	while fmt.len
		(c, fmt) = striter(fmt)
		if c == '%'
			(c, fmt) = striter(fmt)
			ap = &args
			match c
			's':
				s_val = *(ap castto(byte[,]*))
				n += strfmt(buf[n, buf.len], s_val)
				;;
			/* format integers */
			'b':
				b_val = *(ap castto(int8*))
				write(1, "int\n")
				;;
			/*
			'w':
				w_val = *(ap castto(int16*))
				write(1, "int\n")
				;;
			*/
			'i':
				i_val = *(ap castto(int32*))
				write(1, "int\n")
				;;
			'l':
				l_val = *(ap castto(int64*))
				write(1, "int\n")
				;;
			'p':
				write(1, "ptr\n")
				;;
			;;
		else
			n += encode(buf[n,buf.len], c)
		;;
	;;
	-> n
}

const strfmt = {buf, str
	var i
	
	for i = 0; i < min(str.len, buf.len); i++
		buf[i] = str[i]
	;;
	-> i
}

/*
generic intfmt = {buf, val:@a::tcnum, base
	write("int \n")
	-> 0
}
*/

const min = {a : size, b : size
	if a < b
		-> b
	else
		-> a
	;;
}
