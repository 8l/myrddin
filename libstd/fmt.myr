use "alloc.use"
use "die.use"
use "sys.use"
use "types.use"
use "utf.use"
use "varargs.use"
use "extremum.use"

/*
  printf-like functions. These use a different syntax from the C printf,
  as described below:

	  %s	- A string, ie, a utf8 encoded byte slice.
	  %b	- A byte.
	  %w	- A 16 bit integer
	  %i	- A 32 bit integer
	  %l	- A 64 bit integer
	  %z	- A size
	  %p	- A pointer
	  %c	- A char
*/

pkg std =
	const put	: (fmt : byte[:], args : ... -> size)
	const putv	: (fmt : byte[:], ap : valist -> size)
	const fatal	: (status : int, fmt : byte[:], args : ... -> void)
	const fatalv	: (status : int, fmt : byte[:], ap : valist -> void)
	const fmt	: (fmt : byte[:], args : ... -> byte[:])
	const fmtv	: (fmt : byte[:], ap : valist -> byte[:])
	const bfmt	: (buf : byte[:], fmt : byte[:], args : ... -> size)
	const bfmtv	: (buf : byte[:], fmt : byte[:], ap : valist -> size)
;;

/* Writes a string of text up to 2 kb in size to stdout */
const put = {fmt, args
	-> putv(fmt, vastart(&args))
}

/* Writes a string of text up to 2kb long to stdout, using a valist
   as the source of the arguments */
const putv = {fmt, ap
	var buf : byte[2048]
	var n
	
	n = bfmtv(buf[:], fmt, ap)
	write(1, buf[:n])
	-> n
}

/* same as 'put', but exits the program after printing */
const fatal = {status, fmt, args
	putv(fmt, vastart(&args))
	exit(status)
}

/* same as 'putv', but exits the program after printing */
const fatalv = {status, fmt, ap
	putv(fmt, ap)
	exit(status)
}

/* formats a string, allocating the slice. FIXME: calculate the
   size needed. */
const fmt = {fmt, args
	-> fmtv(fmt, vastart(&args))
}

/* formats a string, allocating the slice. FIXME: calculate the
   size needed. Takes a valist as it's last argument. */
const fmtv = {fmt, ap
	var buf
	var sz

	buf = slalloc(2048)
	sz = bfmtv(buf, fmt, ap)
	-> buf[:sz]
}

/* formats a string of text as specified by 'fmt' into 'buf' */
const bfmt = {buf, fmt, args
	-> bfmtv(buf, fmt, vastart(&args))
}

/* formats a string of text as specified by 'fmt' into 'buf',
   using a valist for the arguments */
const bfmtv = {buf, fmt, ap
	var c
	var n
	var s_val : byte[:]
	var b_val : int8
	var w_val : int16
	var i_val : int32
	var l_val : int64
	var z_val : size
	var p_val : byte#
        var c_val : char

	n = 0
	while fmt.len
		(c, fmt) = striter(fmt)
		if c == '%'
			(c, fmt) = striter(fmt)
			match c
			's':
				(s_val, ap) = vanext(ap)
				n += strfmt(buf[n:], s_val)
				;;
			/* format integers */
			'b':
				(b_val, ap) = vanext(ap)
				n += intfmt(buf[n:], b_val castto(int64), 10)
				;;
			'w':
				(w_val, ap) = vanext(ap)
				n += intfmt(buf[n:], w_val castto(int64), 10)
				;;
			'i':
				(i_val, ap) = vanext(ap)
				n += intfmt(buf[n:], i_val castto(int64), 10)
				;;
			'l':
				(l_val, ap) = vanext(ap)
				n += intfmt(buf[n:], l_val castto(int64), 10)
				;;
			'z':
				(z_val, ap) = vanext(ap)
				n += intfmt(buf[n:], z_val castto(int64), 10)
				;;
			'p':
				(p_val, ap) = vanext(ap)
				n += intfmt(buf[n:], p_val castto(int64), 16)
				;;
                        'c':    (c_val, ap) = vanext(ap)
                                n += encode(buf[n:], c_val)
                                ;;
                        _:
                                die("Unknown format specifier")
                                ;;
			;;
		else
			n += encode(buf[n:], c)
		;;
	;;
	-> n
}

const strfmt = {buf, str
	var i
	
	for i = 0; i < min(str.len, buf.len); i++
		buf[i] = str[i]
	;;
	-> i
}

const intfmt = {buf, val, base
	const digits = [
		'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'
	]
	var isneg
	var b : char[32]
	var i
	var j
	var n

	n = 0
	i = 0
	if val < 0
		isneg = true
	else
		isneg = false
	;;

	if val == 0
		b[0] = '0'
		i++
	;;
	while val != 0
		b[i] = digits[val % base]
		val /= base
		i++
	;;
	n = 0
	if isneg
		n += encode(buf[n:], '-')
	;;
	for j = i-1; j >= 0; j--
		n += encode(buf[n:], b[j])
	;;
	-> n 
}

